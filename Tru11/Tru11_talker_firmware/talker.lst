D:\Documents\Programming\MCU\68HC11\TruHC11\v3\Tru11_talker_firmware\v2\talker.lst - generated by MGTEK Assembler ASM11 V1.26 Build 144 for WIN32 (x86) - Sun Sep 15 12:55:02 2024

    1:                                 ; MIT License
    2:                                 ;
    3:                                 ; Copyright (c) 2024 Truong Hy
    4:                                 ;
    5:                                 ; Permission is hereby granted, free of charge, to any person obtaining a copy
    6:                                 ; of this software and associated documentation files (the "Software"), to deal
    7:                                 ; in the Software without restriction, including without limitation the rights
    8:                                 ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    9:                                 ; copies of the Software, and to permit persons to whom the Software is
   10:                                 ; furnished to do so, subject to the following conditions:
   11:                                 ;
   12:                                 ; The above copyright notice and this permission notice shall be included in all
   13:                                 ; copies or substantial portions of the Software.
   14:                                 ;
   15:                                 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   16:                                 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   17:                                 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   18:                                 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   19:                                 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   20:                                 ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   21:                                 ; SOFTWARE.
   22:                                 
   23:                                 ; 03 Aug 2024 - Truong Hy
   24:                                 ; Talker firmware to read memory and program EEPROM
   25:                                 ;
   26:                                 ; Description
   27:                                 ; ===========
   28:                                 ;
   29:                                 ; Enables host computer to control the MCU through the serial port in
   30:                                 ; bootstrap mode.  Provides these controls:
   31:                                 ; - read memory
   32:                                 ; - write normal memory
   33:                                 ; - program EEPROM
   34:                                 ; - program EPROM
   35:                                 ;
   36:                                 ; Only need MODA + MODB tied to ground, serial pins TX+RX wired to a TTL serial
   37:                                 ; adapter to host.
   38:                                 ;
   39:                                 ; Commands and communication flow
   40:                                 ; ===============================
   41:                                 ;
   42:                                 ; Read memory command
   43:                                 ; 1. Host sends $01
   44:                                 ; 2. MCU replies with $01 (echo)
   45:                                 ; 3. Host sends byte count. A value from 0 to 255 (Note 0 = 256 bytes)
   46:                                 ; 4. Host sends high byte of start read address
   47:                                 ; 5. Host sends low byte of start read address
   48:                                 ; 6. MCU sends byte of memory, increments read address and decrements byte count
   49:                                 ; 7. Repeat from 6 until byte count is zero
   50:                                 ;
   51:                                 ; Write normal memory (RAM or memory-mapped register) command
   52:                                 ; 1. Host sends $02
   53:                                 ; 2. MCU replies with $02 (echo)
   54:                                 ; 3. Host sends byte count. A value from 0 to 255 (Note 0 = 256 bytes)
   55:                                 ; 4. Host sends high byte of start write address
   56:                                 ; 5. Host sends low byte of start write address
   57:                                 ; 7. MCU replies with byte written (reread)
   58:                                 ; 8. MCU increments read address and decrements byte count, repeat from 6 until byte count is zero
   59:                                 ;
   60:                                 ; Write EEPROM command
   61:                                 ; 1. Host sends $03
   62:                                 ; 2. MCU replies with $03 (echo)
   63:                                 ; 3. Host sends byte count. A value from 0 to 255 (Note 0 = 256 bytes)
   64:                                 ; 4. Host sends high byte of start write address
   65:                                 ; 5. Host sends low byte of start write address
   66:                                 ; 6. Host sends byte of memory
   67:                                 ; 7. MCU replies with byte programmed (reread)
   68:                                 ; 8. MCU increments read address and decrements byte count, repeat from 6 until byte count is zero
   69:                                 ;
   70:                                 ; Write EPROM command (excluding MC68HC711E20)
   71:                                 ; 1. Host sends $04
   72:                                 ; 2. MCU replies with $04 (echo)
   73:                                 ; 3. Host sends byte count. A value from 0 to 255 (Note 0 = 256 bytes)
   74:                                 ; 4. Host sends high byte of start write address
   75:                                 ; 5. Host sends low byte of start write address
   76:                                 ; 6. Host sends byte of memory
   77:                                 ; 7. MCU replies with byte programmed (reread)
   78:                                 ; 8. MCU increments read address and decrements byte count, repeat from 6 until byte count is zero
   79:                                 ;
   80:                                 ; Write MC68HC711E20 EPROM command
   81:                                 ; 1. Host sends $05
   82:                                 ; 2. MCU replies with $05 (echo)
   83:                                 ; 3. Host sends byte count. A value from 0 to 255 (Note 0 = 256 bytes)
   84:                                 ; 4. Host sends high byte of start write address
   85:                                 ; 5. Host sends low byte of start write address
   86:                                 ; 6. Host sends byte of memory
   87:                                 ; 7. MCU replies with byte programmed (reread)
   88:                                 ; 8. MCU increments read address and decrements byte count, repeat from 6 until byte count is zero
   89:                                 
   90:                                 ; Stack options at top of RAM
   91:          =000000FF              Stack        EQU $00FF                 ; for A and 811E2
   92:                                 ;Stack       EQU $01FF                 ; for E0, E1, E9
   93:                                 ;Stack       EQU $02FF                 ; for E20
   94:                                 ;Stack       EQU $03FF                 ; for F1
   95:                                 
   96:                                 ; Counter value for 10ms delay when using 8MHz xtal
   97:                                 ; The delay loop (excluding call, setup and return) takes 6 cycles (DEX = 3 & BNE = 3), so with an 8 MHz crytal and 2 MHz E clock (0.5us),
   98:                                 ; the loop time is 6 * 0.5us = 3us, so a counter value for a delay of 10 ms is: 10ms*1000/3us = 10000/3 = 3333 (truncated)
   99:          =00000D05              DelayAmt     EQU 10000/3
  100:                                 
  101:                                 ; Register address constants
  102:          =00001000              RegBase      EQU $1000                 ; Base address of memory mapped registers
  103:          =0000002B              BAUD_OFS     EQU $2B
  104:          =0000002C              SCCR1_OFS    EQU $2C
  105:          =0000002D              SCCR2_OFS    EQU $2D
  106:          =0000002E              SCSR_OFS     EQU $2E
  107:          =0000002F              SCDR_OFS     EQU $2F
  108:          =00000035              BPROT_OFS    EQU $35
  109:          =0000003B              PPROG_OFS    EQU $3B
  110:          =00000036              EPROG_OFS    EQU $36
  111:          =0000003C              HPRIO_OFS    EQU $3C
  112:          =0000103F              CONFIG       EQU $103F
  113:                                 
  114:                                 ; Bitmasks
  115:          =00000080              TDRE         EQU $80
  116:          =00000020              RDRF         EQU $20
  117:          =00000016              EEByteErase  EQU $16
  118:          =00000006              EEBulkErase  EQU $06
  119:          =00000002              EEByteProg   EQU $02
  120:          =00000020              EByteProg    EQU $20
  121:                                 
  122:                                 ; Our own address constants
  123:          =00000000              EEOpt        EQU $0000
  124:                                 
  125:                                 ; Main
  126:                                 ; Initialisations
  127:          =00000000                           ORG  $0
  128:     0000 8E 00FF                             LDS  #Stack               ; Load stack pointer
  129:     0003 CE 1000                             LDX  #RegBase             ; Load X register with the base address of memory mapped registers
  130:     0006 6F 2C                               CLR  SCCR1_OFS,X          ; SCCR1 register: ($102C) = $00. Together with next few lines, initialise SCI + BAUD registers for 8 data bits, 9600 baud
  131:     0008 CC 300C                             LDD  #$300C               ; D register = $300C. A register = $30, B register = $0C
  132:     000B A7 2B                               STAA BAUD_OFS,X           ; Store A into BAUD register: ($102B) = $30 (Set 9612 baud with an 8MHz crystal, good enough to communicate at 9600 baud)
  133:     000D E7 2D                               STAB SCCR2_OFS,X          ; Store B into SCCR2 register: ($102D) = $0C
  134:     000F 6F 35                               CLR  BPROT_OFS,X          ; Clear the block protect register (BPROT), which allows EEPROM programming
  135:     0011 86 66                               LDAA #$66                 ; A = $66.  Value for HPRIO
  136:     0013 A7 3C                               STAA HPRIO_OFS,X          ; HPRIO ($103C) = A.  Switch to Special Test mode, RBOOT = 0, IRV = 0.  This enables config register programming and also access to external memory areas
  137:                                 
  138:                                 ; Command input loop: Wait for command from host loop
  139:     0015 7F 0000                ReadCmd      CLR EEOpt
  140:     0018 8D 61                               BSR ReadEchoSerA
  141:     001A 81 01                               CMPA #$01
  142:     001C 27 12                               BEQ ReadMemCmd
  143:     001E 81 02                               CMPA #$02
  144:     0020 27 26                               BEQ WriteMemCmd
  145:     0022 81 03                               CMPA #$03
  146:     0024 27 1F                               BEQ WriteEECmd
  147:     0026 81 04                               CMPA #$04
  148:     0028 27 18                               BEQ WriteECmd
  149:     002A 81 05                               CMPA #$05
  150:     002C 27 11                               BEQ WriteE20Cmd
  151:     002E 20 E5                               BRA ReadCmd               ; Loop when no command
  152:                                 
  153:                                 ; Read command: Read memory and send to host
  154:     0030 8D 36                  ReadMemCmd   BSR MemParams
  155:     0032 18A6 00                ReadMem      LDAA $00,Y                ; Read memory value into A reg
  156:     0035 8D 4A                               BSR WriteSerA             ; Send byte to host
  157:     0037 1808                                INY                       ; Increment address
  158:     0039 5A                                  DECB                      ; Decrement byte count
  159:     003A 26 F6                               BNE ReadMem               ; Loop until all bytes done
  160:     003C 7E 0015                             JMP ReadCmd
  161:                                 
  162:                                 ; EEOpt: 3 = E20 EPROM, 2 = EPROM, 1 = EEPROM, 0 = Normal memory
  163:                                 
  164:                                 ; Write EPROM E20 command
  165:     003F 7C 0000                WriteE20Cmd  INC EEOpt
  166:                                 
  167:                                 ; Write EPROM command
  168:     0042 7C 0000                WriteECmd    INC EEOpt
  169:                                 
  170:                                 ; Write EEPROM command
  171:     0045 7C 0000                WriteEECmd   INC EEOpt
  172:                                 
  173:                                 ; Write command: Receive byte from host then write normal memory or program EEPROM/EPROM
  174:     0048 8D 1E                  WriteMemCmd  BSR MemParams
  175:     004A 1F 2E 20 FC            WriteMem     BRCLR SCSR_OFS,X,#RDRF,*  ; Wait for receive buffer full
  176:     004E A6 2F                               LDAA SCDR_OFS,X           ; Read byte from host into A register, then below echo back to host
  177:     0050 7D 0000                             TST EEOpt
  178:     0053 27 03                               BEQ NoProg                ; If EEOpt = 0 or negative then NoProg
  179:     0055 7E 0088                             JMP Prog                  ; Program byte to EEPROM
  180:     0058 18A7 00                NoProg       STAA $00,Y                ; Write to memory
  181:     005B 18A6 00                ProgReturn   LDAA $00,Y                ; Reread memory
  182:     005E 8D 21                               BSR WriteSerA             ; Send byte to host
  183:     0060 1808                                INY                       ; Increment address
  184:     0062 5A                                  DECB                      ; Decrement byte count
  185:     0063 26 E5                               BNE WriteMem              ; Loop until all bytes done
  186:     0065 7E 0015                             JMP ReadCmd
  187:                                 
  188:                                 ; Read memory parameters from host
  189:     0068 8D 0A                  MemParams    BSR ReadSerB              ; Read byte count from host
  190:     006A 188F                                XGDY                      ; Save command & byte count to IY reg
  191:     006C 8D 06                               BSR ReadSerB              ; Read high byte of address from host
  192:     006E 17                                  TBA                       ; Transfer high byte to A reg
  193:     006F 8D 03                               BSR ReadSerB              ; Read low byte of address from host
  194:     0071 188F                                XGDY                      ; Restore command byte to A reg, byte count to B reg, and save address to IY reg
  195:     0073 39                                  RTS
  196:                                 
  197:                                 ; Read serial no echo
  198:     0074 1F 2E 20 FC            ReadSerB     BRCLR SCSR_OFS,X,#RDRF,*  ; Wait for receive buffer full
  199:     0078 E6 2F                               LDAB SCDR_OFS,X           ; Read byte from host into B register
  200:     007A 39                                  RTS
  201:                                 
  202:                                 ; Read serial with echo
  203:     007B 1F 2E 20 FC            ReadEchoSerA BRCLR SCSR_OFS,X,#RDRF,*  ; Wait for receive buffer full
  204:     007F A6 2F                               LDAA SCDR_OFS,X           ; Read byte from host into A register, then below echo back to host
  205:                                 
  206:                                 ; Write serial
  207:     0081 1F 2E 80 FC            WriteSerA    BRCLR SCSR_OFS,X,#TDRE,*  ; Wait for transmit buffer empty
  208:     0085 A7 2F                               STAA SCDR_OFS,X           ; Write byte from A register to host
  209:     0087 39                                  RTS
  210:                                 
  211:                                 ; Program EEPROM or EPROM. Y = address, A = byte to program
  212:     0088 37                     Prog         PSHB                       ; Save B reg
  213:     0089 D6 00                               LDAB EEOpt
  214:     008B C1 03                               CMPB #$03
  215:     008D 27 2A                               BEQ DoE20Prog
  216:     008F C1 02                               CMPB #$02
  217:     0091 27 14                               BEQ DoEProg
  218:     0093 C6 16                  EEErase      LDAB #EEByteErase          ; Set default byte erase mode
  219:     0095 188C 103F                           CPY #CONFIG                ; If address is CONFIG then bulk erase
  220:     0099 26 02                               BNE ProgDefault
  221:     009B C6 06                               LDAB #EEBulkErase          ; Set bulk erase mode for compatibility with A1, A8 and A2 series
  222:     009D 8D 0E                  ProgDefault  BSR DoProg                 ; Byte erase or bulk erase + CONFIG
  223:     009F C6 02                               LDAB #EEByteProg           ; Set program mode
  224:     00A1 8D 0A                               BSR DoProg                 ; Program byte
  225:     00A3 33                     ProgExit     PULB                       ; Restore B reg
  226:     00A4 7E 005B                             JMP ProgReturn
  227:     00A7 C6 20                  DoEProg      LDAB #EByteProg            ; Set program mode
  228:     00A9 8D 02                               BSR DoProg                 ; Program byte
  229:     00AB 20 F6                               BRA ProgExit
  230:     00AD E7 3B                  DoProg       STAB PPROG_OFS,X           ; Enable internal addr/data latches
  231:     00AF 18A7 00                             STAA $00,Y                 ; Write byte to address
  232:     00B2 6C 3B                               INC PPROG_OFS,X            ; Enable internal programming voltage
  233:     00B4 8D 12                               BSR Delay
  234:     00B6 6F 3B                               CLR PPROG_OFS,X            ; Disable internal programming voltage and release internal addr/data latches
  235:     00B8 39                                  RTS
  236:     00B9 C6 20                  DoE20Prog    LDAB #EByteProg            ; Set program mode
  237:     00BB E7 36                               STAB EPROG_OFS,X           ; Enable internal addr/data latches
  238:     00BD 18A7 00                             STAA $00,Y                 ; Write byte to address
  239:     00C0 6C 36                               INC EPROG_OFS,X            ; Enable internal programming voltage
  240:     00C2 8D 04                               BSR Delay
  241:     00C4 6F 36                               CLR EPROG_OFS,X            ; Disable internal programming voltage and release internal addr/data latches
  242:     00C6 20 DB                               BRA ProgExit
  243:     00C8 3C                     Delay        PSHX
  244:     00C9 CE 0D05                             LDX #DelayAmt              ; Delay amount
  245:     00CC 09                     Wait         DEX
  246:     00CD 26 FD                               BNE Wait
  247:     00CF 38                                  PULX
  248:     00D0 39                                  RTS
  249:                                 
  250:                                     END

Symbols:
baud_ofs                        *0000002b
bprot_ofs                       *00000035
config                          *0000103f
delay                           *000000c8
delayamt                        *00000d05
doe20prog                       *000000b9
doeprog                         *000000a7
doprog                          *000000ad
ebyteprog                       *00000020
eebulkerase                     *00000006
eebyteerase                     *00000016
eebyteprog                      *00000002
eeerase                          00000093
eeopt                           *00000000
eprog_ofs                       *00000036
hprio_ofs                       *0000003c
memparams                       *00000068
noprog                          *00000058
pprog_ofs                       *0000003b
prog                            *00000088
progdefault                     *0000009d
progexit                        *000000a3
progreturn                      *0000005b
rdrf                            *00000020
readcmd                         *00000015
readechosera                    *0000007b
readmem                         *00000032
readmemcmd                      *00000030
readserb                        *00000074
regbase                         *00001000
sccr1_ofs                       *0000002c
sccr2_ofs                       *0000002d
scdr_ofs                        *0000002f
scsr_ofs                        *0000002e
stack                           *000000ff
tdre                            *00000080
wait                            *000000cc
writee20cmd                     *0000003f
writeecmd                       *00000042
writeeecmd                      *00000045
writemem                        *0000004a
writememcmd                     *00000048
writesera                       *00000081

