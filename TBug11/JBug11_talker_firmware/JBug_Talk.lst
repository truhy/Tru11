D:\Documents\Programming\MCU\68HC11\TBug11\JBug11_talker_firmware\JBug_Talk.lst - generated by MGTEK Assembler ASM11 V1.26 Build 144 for WIN32 (x86) - Sun Sep 22 18:40:39 2024

    1:                                 ; JB assembly file for talkers
    2:                                 
    3:                                 ; This file may be used to assemble talkers for A, E and F1 variants of the MC68HC11
    4:                                 
    5:                                 ; This assembly language file will produce talkers identical with the Motorola ones,
    6:                                 ; but note that a leading $FF must be added to establish the baud rate.
    7:                                 
    8:                                 ; Use the conditional assemby commands below to select the type of interrupt
    9:                                 ; control mechanism which JBug11 will use to get control of the MCU:
   10:                                 
   11:                                 ; 27 Jul 2024 - Notes by Truong Hy
   12:                                 ; It seems JBug11 doesn't work with USB-to-TTL serial adapters. I've made modifications which enables
   13:                                 ; it to work with my own commandline talker application:
   14:                                 ;   - my app accepts talker firmware in s-record format, so no need for the binary .BOO or .XOO format
   15:                                 ;   - my app sends the sync character $FF for upload, so no need to append that to the talker firmware
   16:                                 ;   - my app does not use/wait for the serial break so all USB-to-TTL serial adapters should now work
   17:                                 ;   - option added to work without needing the XIRQ/IRQ pins to be pulled up
   18:                                 ; Modifications:
   19:                                 ;   - Added $02 option for no interrupt
   20:                                 ;
   21:                                 ; Note, the original developer is John Beatty, I have no idea of the license but I would like to
   22:                                 ; keep it as it was.
   23:                                 
   24:                                                                         ; Note: if programming EPROM, in addition to the 12V on XIRQ/VPPE pin, a pull-up resistor on IRQ pin is also required (4.7K or 10K)
   25:          =00000002              IntType         EQU     $02             ; $00 for a .BOO talker using IRQ. Pull-up resistor on IRQ pin is required (4.7K or 10K)
   26:                                                                         ; $01 for a .XOO talker using XIRQ.  Pull-up resistor on XIRQ pin is required (4.7K or 10K)
   27:                                                                         ; $02 for a talker using polling.  Generally does not require pull-up resistors on IRQ/XIRQ pins
   28:                                 
   29:                                 ; Select where the stack will go:
   30:                                 
   31:          =000000ED              Stack           EQU     $00ED           ; for A and 811E2
   32:                                 ;Stack          EQU     $01FF           ; for E0, E1, E9
   33:                                 ;Stack          EQU     $02FF           ; for E20
   34:                                 ;Stack          EQU     $03FF           ; for F1
   35:                                 
   36:                                 
   37:          =00001000              RegBase         EQU     $1000           ; Base address for control registers
   38:          =0000002E              oSCSR           EQU     $2E             ; Offset to SCI status register
   39:          =0000002F              oSCDR           EQU     $2F             ; Offset to SCI data register
   40:          =0000002B              oBAUD           EQU     $2B             ; Offset to the BAUD register
   41:          =0000002C              oSCCR1          EQU     $2C             ; Offset to SCI control register 1
   42:          =0000002D              oSCCR2          EQU     $2D             ; Offset to SCI control register 2
   43:          =0000102E              SCSR            EQU     RegBase + oSCSR ; SCI status register
   44:          =0000102F              SCDR            EQU     RegBase + oSCDR ; SCI data register
   45:                                 
   46:                                 
   47:          =00000000              talker_start    EQU     $0000
   48:                                 
   49:          =00000000                              ORG     talker_start
   50:                                 
   51:                                 ; Set the stack pointer SP to a suitable value for the chip
   52:                                 
   53:     0000 8E 00ED                                LDS     #Stack
   54:                                 
   55:                                 ; Set up the SCI for communication with the host
   56:                                 
   57:     0003 CE 1000                                LDX     #RegBase
   58:     0006 6F 2C                                  CLR     oSCCR1,X        ; Clear SCCR1, i.e. 1 start, 8 data,
   59:                                                                         ; 1 stop; and idle-line wake-up
   60:                                 
   61:                                 ; Load the BAUD and SCCR2 registers. BAUD is loaded with $30 for a communication rate
   62:                                 ; of 9612 with an 8MHz crystal. This is the closest available rate to 9600, and quite
   63:                                 ; close enough to work with the UART in PC's
   64:                                 
   65:                                 ; SCCR2 is loaded with either $2C for a .BOO type talker, or $0C for an .XOO one.
   66:                                 
   67:                                 ; $2C means:
   68:                                 ; TIE   Transmit interrupt enable               = 0
   69:                                 ; TCIE  Transmit complete interrupt enable      = 0
   70:                                 ; RIE   Receive interrupt enable                = 1 for a .BOO talker
   71:                                 ; ILIE  Idle line interrupt enable              = 0
   72:                                 ; TE    Transmit enable                         = 1
   73:                                 ; RE    Receive enable                          = 1
   74:                                 ; RWU   Receiver wake-up                        = 0
   75:                                 ; SBK   Send break                              = 0
   76:                                 
   77:                                 ; $0C means:
   78:                                 ; TIE   Transmit interrupt enable               = 0
   79:                                 ; TCIE  Transmit complete interrupt enable      = 0
   80:                                 ; RIE   Receive interrupt enable                = 0 for an .XOO talker
   81:                                 ; ILIE  Idle line interrupt enable              = 0
   82:                                 ; TE    Transmit enable                         = 1
   83:                                 ; RE    Receive enable                          = 1
   84:                                 ; RWU   Receiver wake-up                        = 0
   85:                                 ; SBK   Send break                              = 0
   86:                                 
   87:                                 #IF IntType == $00
   89:                                 #ENDIF
   90:                                 #IF IntType == $01
   92:                                 #ENDIF
   93:                                 #IF IntType == $02
   94:     0008 CC 300C                                LDD     #$300C
   95:                                 #ENDIF
   96:                                 
   97:     000B A7 2B                                  STAA    oBAUD,X         ; 9600 baud. $2B is the BAUD register offset
   98:                                 
   99:                                 ;
  100:     000D E7 2D                                  STAB    oSCCR2,X        ; See note above
  101:                                 
  102:                                 #IF IntType == $00
  106:                                 #ENDIF
  107:                                 #IF IntType == $01
  111:                                 #ENDIF
  112:                                 
  113:                                 ;
  114:                                 ;talker_idle    JMP     talker_idle     ; Hang-around loop
  115:                                 
  116:     000F B6 102E                sci_srv         LDAA    SCSR            ; Load A with the SCI status register
  117:     0012 84 20                                  ANDA    #$20            ; AND it with the RDRF mask
  118:                                                                         ; (receive data register full)
  119:     0014 27 F9                                  BEQ     sci_srv         ; loop back if RDRF is zero
  120:                                 
  121:                                 ; Talker code to process received byte
  122:                                 
  123:     0016 B6 102F                                LDAA    SCDR            ; Load A with SCDR, the SCI Data Register
  124:                                 
  125:                                 ; Echo the received character back to the host in inverted form
  126:                                 ; inverted as a safety precaution?
  127:                                 
  128:     0019 43                                     COMA                    ; Do a one's complement
  129:     001A 8D 4A                                  BSR     OutSci          ; and echo to host
  130:                                 
  131:                                 ; The most significant bit of command bytes is used as a flag that what follows is a
  132:                                 ; command to read or write the CPU inherent registers. This bit is tested next, by the
  133:                                 ; Branch if Plus (BPL) operation, remembering that the command byte has been inverted
  134:                                 
  135:     001C 2A 55                                  BPL     Inh1            ; branch if inherent register command
  136:                                 
  137:                                 ; Else read byte count from host into ACCB
  138:                                 
  139:     001E 8D 37                                  BSR     InSci           ; Read byte count from host
  140:                                 
  141:     0020 8F                                     XGDX                    ; Save command & byte count in IX
  142:                                 
  143:                                 ; Read the high address byte from host into ACCA, then read low address byte into ACCB
  144:                                 
  145:     0021 8D 34                                  BSR     InSci           ; Read
  146:     0023 17                                     TBA                     ; Result returns in B, so move to A
  147:     0024 8D 31                                  BSR     InSci           ; Read
  148:                                 
  149:                                 ; Restore (inverted) command byte to A, byte count to B, and save address in IX
  150:                                 
  151:     0026 8F                                     XGDX
  152:                                 
  153:                                 ; Is the command a 'memory read'?  Check by comparing the (inverted) command with $FE
  154:                                 ; This implies original memory read command is $01
  155:                                 
  156:     0027 81 FE                                  CMPA    #$FE
  157:     0029 26 0F                                  BNE     RxSrv1          ; Maybe it's a 'memory write' command ?
  158:                                 
  159:                                 ; Following section reads memory and sends it to the host
  160:                                 
  161:     002B A6 00                  TReadMem        LDAA    $00,X           ; Fetch byte from memory
  162:     002D 8D 37                                  BSR     OutSci          ; Send byte to host
  163:     002F 17                                     TBA                     ; Save byte count
  164:     0030 8D 25                                  BSR     InSci           ; Wait for host acknowledgement (may be any char)
  165:     0032 16                                     TAB                     ; Restore byte count
  166:     0033 08                                     INX                     ; Increment address
  167:     0034 5A                                     DECB                    ; Decrement byte count
  168:     0035 26 F4                                  BNE     TreadMem        ; branch until done
  169:                                 #IF IntType == $00
  171:                                 #ENDIF
  172:                                 #IF IntType == $01
  174:                                 #ENDIF
  175:                                 #IF IntType == $02
  176:     0037 7E 000F                                JMP     sci_srv         ; Jump to receive wait loop
  177:                                 #ENDIF
  178:                                 
  179:                                 ; Is the command a 'memory write'?  Check by comparing the (inverted) command with $BE
  180:                                 ; This implies original memory write command is $41
  181:                                 
  182:     003A 81 BE                  RxSrv1          CMPA    #$BE            ; If unrecognised command received simply return
  183:     003C 26 16                                  BNE     NullSrv         ; i.e. branch to an RTI
  184:                                 
  185:                                 ; Following section writes bytes from the host to memory
  186:                                 
  187:     003E 17                                     TBA                     ; Save byte count in A
  188:                                 
  189:                                 ; Read the next byte from the host.  Byte goes into B
  190:                                 
  191:     003F 8D 16                  TWritMem        BSR     InSci           ; Read byte
  192:     0041 E7 00                                  STAB    $00,X           ; Store it at the next address
  193:                                 
  194:                                 ; Run a 'wait' loop to allow for external EEPROM.  The value of the LDY operand has to
  195:                                 ; be adjusted to allow for the time it takes to program the EEPROM. In the standard
  196:                                 ; talker this value is 1.
  197:                                 
  198:                                 ; The loop takes 7 cycles, so with an 8 MHz crytal and 2 MHz E clock, the loop time
  199:                                 ; is 7 * 0.5 µs = 3.5 µs. So for a delay of 5 ms, we need to load IY with
  200:                                 ; 5000/3.5 = 1429  This facility is used for the MicroStamp11 'D' series talker
  201:                                 
  202:     0043 18CE 0001                              LDY     #$0001          ; Set up wait loop and run
  203:     0047 1809                   WaitPoll        DEY                     ; [4]
  204:     0049 26 FC                                  BNE     WaitPoll        ; [3]
  205:                                 
  206:     004B E6 00                                  LDAB    $00,X           ; Read stored byte, and
  207:     004D F7 102F                                STAB    SCDR            ; echo back to host
  208:                                 
  209:     0050 08                                     INX                     ; Increment memory location
  210:     0051 4A                                     DECA                    ; Decrement byte count
  211:     0052 26 EB                                  BNE     TWritMem        ; until all done
  212:                                 
  213:                                 #IF IntType == $00
  215:                                 #ENDIF
  216:                                 #IF IntType == $01
  218:                                 #ENDIF
  219:                                 #IF IntType == $02
  220:     0054 7E 000F                NullSrv         JMP     sci_srv         ; Jump to receive wait loop
  221:                                 #ENDIF
  222:                                 
  223:                                 ; SUBROUTINES TO SEND AND RECEIVE A SINGLE BYTE ***************************************
  224:                                 
  225:                                 ; InSCI gets the received byte from the host PC via the SCI. Byte is returned in B
  226:                                 
  227:     0057 F6 102E                InSCI           LDAB    SCSR            ; Load B from the SCI status register
  228:                                 
  229:                                 ; Test B against $0A, %00001010, for a 'break' character being received.  If a 'break'
  230:                                 ; character is received, then the OR and/or FE flags will be set
  231:                                 
  232:                                 ; TDRE  Transmit data register empty    = ?     (? = irrelevent)
  233:                                 ; TC    Transmit complete               = ?
  234:                                 ; RDRF  Receive data register full      = ?
  235:                                 ; IDLE  Idle-line detect                = ?
  236:                                 ; OR    Overrun error                   = 0
  237:                                 ; NF    Noise flag                      = ?
  238:                                 ; FE    Framing error                   = 0
  239:                                 ; 0                                     = ?
  240:                                 
  241:     005A C5 0A                                  BITB    #$0A            ; If break detected, then
  242:     005C 26 A2                                  BNE     talker_start    ; branch to $0000 - restart talker
  243:                                 
  244:                                 ; Test B against the RDRF mask, $20, %0010:0000
  245:                                 
  246:                                 ; TDRE  Transmit data register empty    = ?
  247:                                 ; TC    Transmit complete               = ?
  248:                                 ; RDRF  Receive data register full      = 1
  249:                                 ; IDLE  Idle-line detect                = ?
  250:                                 ; OR    Overrun error                   = ?
  251:                                 ; NF    Noise flag                      = ?
  252:                                 ; FE    Framing error                   = ?
  253:                                 ; 0     (always reads zero)             = ?
  254:                                 
  255:     005E C4 20                                  ANDB    #$20            ; If RDRF not set then
  256:     0060 27 F5                                  BEQ     InSci           ; listen for char from host
  257:                                 
  258:                                 ; Read data received from host and return it in B
  259:                                 
  260:     0062 F6 102F                                LDAB    SCDR
  261:     0065 39                                     RTS
  262:                                 
  263:                                 ;
  264:                                 ; OutSCI is the subroutine which transmits a byte from the SCI to the host PC
  265:                                 ; Byte to send in A on entry
  266:                                 
  267:     0066 188F                   OutSci          XGDY                    ; save A and B in IY
  268:     0068 B6 102E                OutSci1         LDAA    SCSR            ; Load A from the SCI status register
  269:                                 
  270:                                 ; If TDRE, the Transmit Data Register Empty flag is not set then loop round.
  271:                                 ; Not by chance, the TDRE flag is the msb of the SCI status register
  272:                                 
  273:     006B 2A FB                                  BPL     OutSci1
  274:                                 
  275:     006D 188F                                   XGDY                    ; Restore A and B
  276:     006F B7 102F                                STAA    SCDR            ; Send byte
  277:     0072 39                                     RTS
  278:                                 
  279:                                 ; READING AND WRITING THE CPU INHERENT REGISTERS **************************************
  280:                                 
  281:                                 ; Now decide which CPU inherent register command was sent.  If command is to read the
  282:                                 ; MCU registers then the one's complement of the command will be $7E (command = $81)
  283:                                 
  284:     0073 81 7E                  Inh1            CMPA    #$7E
  285:     0075 26 0C                                  BNE     Inh2            ; Maybe a write of the registers?
  286:                                 
  287:                                 ; READ REGISTERS
  288:                                 
  289:     0077 30                     Inh1a           TSX                     ; Store stack pointer in IX
  290:     0078 8F                                     XGDX                    ; then to D
  291:                                 
  292:                                 ; Send stack pointer to host, high byte first. Note that the value sent is SP+1 because
  293:                                 ; the TSX command increments SP on transfer to IX
  294:                                 
  295:     0079 8D EB                                  BSR     OutSci          ; Send byte
  296:     007B 17                                     TBA
  297:     007C 8D E8                                  BSR     OutSci          ; Send byte
  298:                                 
  299:     007E 30                                     TSX                     ; Again store stack pointer to IX
  300:                                 
  301:                                 ; Use TReadMem to send 9 bytes on the stack
  302:                                 
  303:     007F C6 09                                  LDAB    #$09
  304:     0081 20 A8                                  BRA     TReadMem
  305:                                 
  306:                                 ; If the command was to write MCU registers, then the one's complement of the command
  307:                                 ; would be $3E (command = $C1)
  308:                                 
  309:     0083 81 3E                  Inh2            CMPA    #$3E            ; If not $3E then
  310:     0085 26 11                                  BNE     SwiSrv1         ; Maybe to service an SWI?
  311:                                 
  312:                                 ; WRITE REGISTERS
  313:                                 
  314:                                 ; Get stack pointer from host, high byte first. Note that the host needs to send SP+1
  315:                                 ; because the TXS operation will decrement the IX value by 1 on transfer to SP.
  316:                                 
  317:     0087 8D CE                                  BSR     InSci
  318:     0089 17                                     TBA
  319:     008A 8D CB                                  BSR     InSci
  320:                                 
  321:     008C 8F                                     XGDX                    ; Move to IX
  322:     008D 35                                     TXS                     ; and copy to Stack Pointer
  323:                                 
  324:                                 ; Use TWritMem to get the next nine bytes from the host onto the stack
  325:                                 
  326:     008E 86 09                                  LDAA    #$09
  327:     0090 20 AD                                  BRA     TWritMem
  328:                                 
  329:                                 ;
  330:                                 ; Breakpoints generated by SWI instructions cause this routine to run
  331:                                 ; The code $4A is sent to the host as a signal that a breakpoint has been reached
  332:                                 
  333:     0092 86 4A                  swi_srv         LDAA    #$4A
  334:     0094 8D D0                                  BSR     OutSci
  335:                                 
  336:                                 ; Now enter idle loop until the acknowledge signal is received from the host (also $4A)
  337:                                 
  338:          =00000096              SWIidle         EQU     *
  339:                                 
  340:                                 #IF IntType == $00
  342:                                 #ENDIF
  343:                                 #IF IntType == $01
  345:                                 #ENDIF
  346:                                 
  347:     0096 20 FE                                  BRA     SWIidle
  348:                                 
  349:                                 ; If command from host is an acknowledgement of breakpoint ($B5 complemented, = $4A),
  350:                                 ; then the stack pointer is unwound 9 places, ie to where it was before the host
  351:                                 ; acknowledged the SWI
  352:                                 
  353:     0098 81 4A                  SwiSrv1         CMPA    #$4A
  354:     009A 26 B8                                  BNE     NullSrv         ; branch to $0058 (NullSrv). If not
  355:                                                                         ; $4A then simply return
  356:                                 
  357:                                 ; HOST SERVICE SWI
  358:                                 
  359:     009C 30                                     TSX                     ; Copy stack pointer to IX
  360:     009D C6 09                                  LDAB    #$09            ; Load B with 9
  361:     009F 3A                                     ABX                     ; Add 9 to IX
  362:     00A0 35                                     TXS                     ; Copy IX to the stack pointer
  363:                                 
  364:                                 ; Send the breakpoint return address to the host, high byte first. Note that the address
  365:                                 ; sent is actually the one immediately following the address at which the break occurred.
  366:                                 
  367:     00A1 EC 07                                  LDD     $07,X
  368:     00A3 8D C1                                  BSR     OutSci
  369:     00A5 17                                     TBA
  370:     00A6 8D BE                                  BSR     OutSci
  371:                                 
  372:                                 ; Alter the value of PC on the return stack to be the address of the SWIidle routine, so
  373:                                 ; that after sending the CPU registers to the host the CPU will enter the idle routine
  374:                                 
  375:     00A8 CC 0096                                LDD     #SwiIdle        ; Force idle loop on return from breakpoint
  376:                                                                         ; processing
  377:     00AB ED 07                                  STD     $07,X
  378:     00AD 20 C8                                  BRA     Inh1A           ; Return all CPU registers to host
  379:                                 
  380:                                 ; END OF TALKER CODE ******************************************************************
  381:                                 
  382:                                 ; Following space is blank
  383:                                 
D:\Documents\Programming\MCU\68HC11\TBug11\JBug11_talker_firmware\JBug_Talk.asm(384): Warning A4304: col(13) obsolete directive
  384:     00AF 00 00 00 00 00 00      TalkEnd         FCB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
           00B5 00 00 00 00 00 00 
           00BB 00 00 00 00 00 00 
  385:                                 
  386:                                 ; Interrupt pseudo-vectors.  Unlabelled interrupts all point to NullSrv which is an
  387:                                 ; RTI instruction
  388:                                 
  389:     00C1 7E 000F                                JMP     sci_srv         ; SCI   -> sci_srv
  390:     00C4 7E 0054                                JMP     NullSrv         ; SPI
  391:     00C7 7E 0054                                JMP     NullSrv         ; PAIE
  392:     00CA 7E 0054                                JMP     NullSrv         ; PAO
  393:     00CD 7E 0054                                JMP     NullSrv         ; TO
  394:     00D0 7E 0054                                JMP     NullSrv         ; TOC5
  395:     00D3 7E 0054                                JMP     NullSrv         ; TOC4
  396:     00D6 7E 0054                                JMP     NullSrv         ; TOC3
  397:     00D9 7E 0054                                JMP     NullSrv         ; TOC2
  398:     00DC 7E 0054                                JMP     NullSrv         ; TOC1
  399:     00DF 7E 0054                                JMP     NullSrv         ; TIC3
  400:     00E2 7E 0054                                JMP     NullSrv         ; TIC2
  401:     00E5 7E 0054                                JMP     NullSrv         ; TIC1
  402:     00E8 7E 0054                                JMP     NullSrv         ; RTI
  403:     00EB 7E 0054                                JMP     NullSrv         ; IRQ\
  404:                                 
  405:                                 #IF IntType == $00
  407:                                 #ENDIF
  408:                                 #IF IntType == $01
  410:                                 #ENDIF
  411:                                 #IF IntType == $02
  412:     00EE 7E 000F                xirq_jmp        JMP     sci_srv         ; XIRQ\ -> sci_srv
  413:                                 #ENDIF
  414:                                 
  415:     00F1 7E 0092                                JMP     swi_srv         ; SWI
  416:                                 
  417:          =000000F2              swi_jmp         EQU     * - 2           ; label refers to address
  418:                                 
  419:     00F4 7E 0000                                JMP     talker_start    ; Illegal opcode -> restart
  420:                                 
  421:          =000000F5              illop_jmp       EQU     * - 2           ; label refers to address
  422:                                 
  423:     00F7 7E 0054                                JMP     NullSrv         ; COP fail
  424:     00FA 7E 0054                                JMP     NullSrv         ; Clock Monitor fail
  425:                                 
  426:                                 ; COMMUNICATION FLOW - PC <--> TALKER **********************************************
  427:                                 
  428:                                 ;       Read Memory Bytes
  429:                                 
  430:                                 ;       1.      Host sends $01
  431:                                 ;       2.      MCU replies with $FE (one's complement of $01)
  432:                                 ;       3.      Host sends byte count ($00 to $FF)
  433:                                 ;       4.      Host sends high byte of address
  434:                                 ;       5.      Host sends low byte of address
  435:                                 
  436:                                 ;       6.      MCU  sends first byte of memory
  437:                                 ;       7.      Host acknowledges with any old byte
  438:                                 
  439:                                 ;       8.      Repeat 6 & 7 until all bytes read
  440:                                 
  441:                                 ;       Write Memory bytes
  442:                                 
  443:                                 ;       1.      Host sends $41
  444:                                 ;       2.      MCU replies with $BE (one's complement of $41)
  445:                                 ;       3.      Host sends byte count ($00 to $FF)
  446:                                 ;       4.      Host sends high byte of address
  447:                                 ;       5.      Host sends low byte of address
  448:                                 
  449:                                 ;       6.      Host sends first byte of memory
  450:                                 ;       7.      MCU acknowledges by echoing same byte
  451:                                 
  452:                                 ;       8.      Repeat 6 & 7 until all bytes sent
  453:                                 
  454:                                 ;       Read MCU Registers
  455:                                 
  456:                                 ;       1.      Host sends $81
  457:                                 ;       2.      MCU replies with $7E
  458:                                 ;       3.      MCU  sends high byte of Stack Pointer   } Note 1
  459:                                 ;       4.      MCU  sends low byte of Stack Pointer    }
  460:                                 
  461:                                 ;       5.      MCU  sends lowest byte on stack
  462:                                 ;       6.      Host acknowledges with any old byte
  463:                                 
  464:                                 ;       7.      Repeat steps 5 & 6 for a total of 9 times
  465:                                 ;               Bytes are sent in this order:
  466:                                 ;               CCR
  467:                                 ;               B
  468:                                 ;               A
  469:                                 ;               IXH
  470:                                 ;               IXL
  471:                                 ;               IYH
  472:                                 ;               IYL
  473:                                 ;               PCH
  474:                                 ;               PCL
  475:                                 
  476:                                 ;       Write MCU Registers
  477:                                 
  478:                                 ;       1.      Host sends $C1
  479:                                 ;       2.      MCU replies with $3E
  480:                                 ;       3.      Host sends high byte of Stack Pointer   } Note 2
  481:                                 ;       4.      Host sends low byte of Stack Pointer    }
  482:                                 
  483:                                 ;       5.      Host sends lowest byte on stack
  484:                                 ;       6.      MCU acknowledges by echoing same byte
  485:                                 
  486:                                 ;       7.      Repeat steps 5 & 6 for a total of 9 times
  487:                                 ;               Bytes are sent in this order:
  488:                                 ;               CCR
  489:                                 ;               B
  490:                                 ;               A
  491:                                 ;               IXH
  492:                                 ;               IXL
  493:                                 ;               IYH
  494:                                 ;               IYL
  495:                                 ;               PCH
  496:                                 ;               PCL
  497:                                 
  498:                                 ;
  499:                                 ;       Software Interrupt
  500:                                 
  501:                                 ;       When an SWI is encountered, the MCU transmits the character $4A (ASCII
  502:                                 ;       letter 'J'). This triggers JBug11 to make use of the following routine:
  503:                                 
  504:                                 ;       SWI Service Routine
  505:                                 
  506:                                 ;       1.      Host sends $B5
  507:                                 ;       2.      MCU replies with $4A
  508:                                 
  509:                                 ;       3.      MCU sends high byte of breakpoint address       } Note 3
  510:                                 ;       4.      MCU sends low byte of breakpoint address        }
  511:                                 
  512:                                 ;       5.      MCU sends high byte of Stack Pointer            } Note 1
  513:                                 ;       6.      MCU sends low byte of Stack Pointer             }
  514:                                 ;       7.      MCU sends lowest byte on stack
  515:                                 ;       8.      Host acknowledges by echoing any old byte
  516:                                 
  517:                                 ;       9.      Repeat steps 7 & 8 for a total of 9 times
  518:                                 ;               Bytes are sent in this order:
  519:                                 ;               CCR
  520:                                 ;               B
  521:                                 ;               A
  522:                                 ;               IXH
  523:                                 ;               IXL
  524:                                 ;               IYH
  525:                                 ;               IYL
  526:                                 ;               PCH     } Note 4
  527:                                 ;               PCL     }
  528:                                 
  529:                                 ; NOTES
  530:                                 
  531:                                 ; 1     The MCU sends the actual value of the stack pointer plus 1
  532:                                 ; 2     The host must send the desired value of the stack pointer plus 1
  533:                                 ; 3     The MCU sends the actual value of the breakpoint plus 1
  534:                                 ; 4     The value of PC returned by the SWI service routine is always the address
  535:                                 ;       of SwiIdle.

Symbols:
illop_jmp                        000000f5
inh1                            *00000073
inh1a                           *00000077
inh2                            *00000083
insci                           *00000057
inttype                         *00000002
nullsrv                         *00000054
obaud                           *0000002b
osccr1                          *0000002c
osccr2                          *0000002d
oscdr                           *0000002f
oscsr                           *0000002e
outsci                          *00000066
outsci1                         *00000068
regbase                         *00001000
rxsrv1                          *0000003a
scdr                            *0000102f
sci_srv                         *0000000f
scsr                            *0000102e
stack                           *000000ed
swi_jmp                          000000f2
swi_srv                         *00000092
swiidle                         *00000096
swisrv1                         *00000098
talkend                          000000af
talker_start                    *00000000
treadmem                        *0000002b
twritmem                        *0000003f
waitpoll                        *00000047
xirq_jmp                         000000ee

